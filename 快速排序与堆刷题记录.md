**215数组中的第K个最大元素**

题解：我们这里使用快速排序的方法，快排每次我们都可以确定一个元素的位置，然后根据此位置判断第K个元素在该元素的左边还是右边，然后接着递归。
代码：
~~~
class Solution(object):
    def quick_sort(self, nums, left, right):
        if left < right:
            flag = nums[left]
            start = left
            end = right
            while(left < right):
                while(left < right and flag < nums[right]):
                    right = right - 1
                if left < right:
                    nums[left] = nums[right]
                    left = left + 1
                while(left < right and flag > nums[left]):
                    left = left + 1
                if left < right:
                    nums[right] = nums[left]
                    right = right - 1
            nums[left] = flag
            return left
        
    def travel_list(self, nums, left, right, pos):
        if left < right:
            index = self.quick_sort(nums, left, right)
            if index == pos:
                return nums[index]
            elif index > pos:
                return self.travel_list(nums, left, index  - 1, pos)
            else:
                return self.travel_list(nums, index + 1, right, pos)
        else:
            return nums[pos]

    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        pos = len(nums) - k
        if len(nums) == 1:
            return nums[0] 
        value = self.travel_list(nums, 0, len(nums)-1, pos)
        return value
~~~

**973最接近远点的k个点**

题解：思路跟上面一样也是找到第k个位置，因为我们并不需要管前K个的顺序，只需要拿到就好了，所以这道题目相当于找到第k个最小的点。

代码：
~~~
class Solution(object):
    def quick_sort(self, points, distance, left, right):
        if left < right:
            flag = distance[left]
            flag_p = points[left]
            while(left < right):
                while(left<right and distance[right]>flag):
                    right = right - 1
                if left < right:
                    distance[left] = distance[right]
                    points[left] = points[right]
                    left = left + 1
                while(left<right and distance[left]< flag):
                    left = left + 1
                if left < right:
                    distance[right] = distance[left]
                    points[right] = points[left]
                    right = right - 1
            distance[left] = flag
            points[left] = flag_p
            return left
    
    def travel_list(self, points, distance, left, right, pos):
        if left < right:
            index = self.quick_sort(points, distance, left, right)
            print("index------"+str(index))
            if index == pos:
                return index
            elif index < pos:
                return self.travel_list(points, distance, index + 1, right, pos)
            else:
                return self.travel_list(points, distance, left, index - 1, pos)
        else:
            return pos

    def kClosest(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        len_points = len(points)
        distances = []
        for i in range(0, len_points):
            x = points[i][0]
            y = points[i][1]
            distances.append(x**2+y**2)
        #print(distances)
        #print(points)
        pos = self.travel_list(points, distances, 0, len_points-1, k-1)
        #print(points)
        #print(distances)
        result = []
        for i in range(0, k):
            result.append(points[i])
        return result
~~~

**347前k个高频元素**

题解：与上面的思路是一样的，都是采用快排

代码：
~~~
class Solution(object):
    def quick_sort(self, nums_key, nums_count, left, right):
        if left < right:
            flag = nums_count[left]
            flag_k = nums_key[left]
            while(left < right):
                while(left < right and flag < nums_count[right]):
                    right = right - 1
                if left < right:
                    nums_count[left] = nums_count[right]
                    nums_key[left] = nums_key[right]
                    left = left + 1
                while(left < right and flag > nums_count[left]):
                    left = left + 1
                if left < right:
                    nums_count[right] = nums_count[left]
                    nums_key[right] = nums_key[left]
                    right = right - 1
            nums_count[left] = flag
            nums_key[left] = flag_k
            return left
        
    def travel_list(self, nums_key, nums_count, left, right, pos):
        if left < right:
            index = self.quick_sort(nums_key, nums_count, left, right)
            if index == pos:
                return index
            elif index > pos:
                return self.travel_list(nums_key, nums_count, left, index  - 1, pos)
            else:
                return self.travel_list(nums_key, nums_count, index + 1, right, pos)
        else:
            return pos
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        dic_nums = {}
        for i in nums:
            if i in dic_nums.keys():
                dic_nums[i] = dic_nums[i] + 1
            else:
                dic_nums[i] = 1
        nums_key = []
        nums_count = []
        for key,value in dic_nums.items():
            nums_key.append(key)
            nums_count.append(value)
        index = self.travel_list(nums_key, nums_count, 0, len(nums_key)-1, len(nums_key)-k)
        result = []
        for i in range(index, len(nums_key)):
            result.append(nums_key[i])
        return result
~~~
